@inherits FIRBase<BiArgMonoResPrimOp>

<div id="@SizeWatcherID" class="component primOp sequential" style="left:@Position.X.ToPixels();top:@Position.Y.ToPixels();min-width:@GetCurrentSize().X.ToPixels();min-height:@GetCurrentSize().Y.ToPixels();">
    <button id="switchBase" class="switch-base-btn" @onclick="SwitchBase">
        <span class="oi oi-loop-square" aria-hidden="true"></span>
    </button>

    <div class="content" style="padding:@ContentPadding.ToPixels();">
        <div class="operation">
            <span class="primOpSymbol">@Operation.OpName</span>
            <div class="inputs-result-container">
                <div class="inputs-result">
                    @if (ShowAsBinary)
                    {
                        <div>@Operation.A.UpdateValueFromSourceFast().BitsToString()</div>
                        <div>@Operation.B.UpdateValueFromSourceFast().BitsToString()</div>
                        <div class="result">@Operation.Result.Value.ToBinaryString()</div>
                    } else
                    {
                        <div>@BinToDec(Operation.A.UpdateValueFromSourceFast().BitsToString())</div>
                        <div>@BinToDec(Operation.B.UpdateValueFromSourceFast().BitsToString())</div>
                        <div class="result">@BinToDec(Operation.Result.Value.ToBinaryString())</div>
                    }
                </div>
            </div>
        </div>
    </div>

    @foreach (var input in SinkOffsets)
    {
        <IOPortUI Position="@input.Position" IO="@input.IO"></IOPortUI>
    }

    @foreach (var output in SourceOffsets)
    {
        <IOPortUI Position="@output.Position" IO="@output.IO"></IOPortUI>
    }
</div>



@code
{
    private const int ContentPadding = 5;
    private bool ShowAsBinary = true;
    private bool LockSize = false;

    protected override Task OnResize(int width, int height)
    {
        // We do not want the component to resize after changing the base to display
        // so resizing is locked after clicking the switch base button.
        if (LockSize)
        {
            SetCurrentSize(new Point(width, height));
            return Task.CompletedTask;
        }

        return base.OnResize(width, height);
    }

    protected override DirectedIO[] OnMakeSinks(int width, int height)
    {
        int contentHeight = height - ContentPadding * 2;
        int ioYStart = (contentHeight / 6) + ContentPadding;
        int ioYDistance = contentHeight / 3;

        Point aInputPos = new Point(0, ioYStart);
        Point bInputPos = new Point(0, ioYStart + ioYDistance);

        return new DirectedIO[]
        {
            new DirectedIO(Operation.A, aInputPos, MoveDirs.Right),
            new DirectedIO(Operation.B, bInputPos, MoveDirs.Right)
        };
    }

    protected override DirectedIO[] OnMakeSources(int width, int height)
    {
        int contentHeight = height - ContentPadding * 2;
        int ioYStart = (contentHeight / 6) + ContentPadding;
        int ioYDistance = contentHeight / 3;

        Point outputPos = new Point(width, ioYStart + ioYDistance * 2);

        return new DirectedIO[]
        {
            new DirectedIO(Operation.Result, outputPos, MoveDirs.Right)
        };
    }

    private Task SwitchBase(MouseEventArgs args)
    {
        ShowAsBinary = !ShowAsBinary;
        LockSize = true;
        StateHasChanged();

        return Task.CompletedTask;
    }

    public string BinToDec(string value)
    {
        // BigInteger can be found in the System.Numerics dll
        BigInteger res = 0;

        // I'm totally skipping error handling here
        foreach (char c in value)
        {
            res <<= 1;
            res += c == '1' ? 1 : 0;
        }

        return res.ToString();
    }
}
