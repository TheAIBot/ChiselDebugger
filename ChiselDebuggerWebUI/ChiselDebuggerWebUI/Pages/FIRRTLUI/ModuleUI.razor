@inherits FIRBase<Module>

<div class="module" style="left:@Position.X.ToPixels();top:@Position.Y.ToPixels();">
    <div class="moduleHeader">
        <h2>@Operation.Name</h2>
    </div>
    <div style="padding:@ContentPadding.ToPixels();">
        <div class="moduleContent" @ref="SizeWatcher" style="width:@GetCurrentSize().X.ToPixels();height:@GetCurrentSize().Y.ToPixels();min-width:@MinContentSize.X.ToPixels();min-height:@MinContentSize.Y.ToPixels()">
            @foreach (var posOp in ModuleOpPoses)
            {
                @if (posOp.Value is Mux)
                {
                    <MuxOp PosOp="@(posOp.Cast<Mux>())" ParentModCtrl="CurrModCtrl"></MuxOp>
                }
                else if (posOp.Value is BiArgMonoResPrimOp)
                {
                    <BiArgMonoResPrimOpUI PosOp="@(posOp.Cast<BiArgMonoResPrimOp>())" ParentModCtrl="CurrModCtrl"></BiArgMonoResPrimOpUI>
                }
                else if (posOp.Value is ConstBitRange)
                {
                    <ConstBitRangeUI PosOp="@(posOp.Cast<ConstBitRange>())" ParentModCtrl="CurrModCtrl"></ConstBitRangeUI>
                }
                else if (posOp.Value is Register)
                {
                    <RegisterUI PosOp="@(posOp.Cast<Register>())" ParentModCtrl="CurrModCtrl"></RegisterUI>
                }
            }

            @foreach (var input in InputOffsets)
            {
                <IOPortUI Position="@input.Position"></IOPortUI>
            }

            @foreach (var output in OutputOffsets)
            {
                <IOPortUI Position="@output.Position"></IOPortUI>
            }

            <WiresUI ModCtrl="CurrModCtrl"></WiresUI>
        </div>
    </div>
</div>

@code
{
    private const int ContentPadding = 20;
    private const int MarginForIO = 20;
    private const int MinSpaceBetweenIO = 15;
    private Point MinContentSize;
    private List<Positioned<FIRRTLNode>> ModuleOpPoses = new List<Positioned<FIRRTLNode>>();
    private ModuleController CurrModCtrl;

    protected override void OnFirstParametersSetAsync()
    {
        MinContentSize = GetMinSizeForIO();

        ModuleOpPoses = Operation.GetAllNodes().Select(x => new Positioned<FIRRTLNode>(new Point(0, 0), x)).ToList();
        CurrModCtrl = new ModuleController(Operation);
        CurrModCtrl.OnPlacedNodes += UpdatePlacement;
    }

    protected override bool OnResize(int width, int height)
    {
        base.OnResize(width, height);

        CurrModCtrl.UpdateIOFromNode(Operation, InputOffsets, OutputOffsets);

        return true;
    }

    private Point GetMinSizeForIO()
    {
        int requiredWidth = 0;

        int maxIO = Math.Max(Operation.ExternalInputs.Count, Operation.ExternalOutputs.Count);

        int requiredIOMargin = MarginForIO * 2;
        int requiredHeight = requiredIOMargin + (maxIO - 1) * MinSpaceBetweenIO;

        return new Point(requiredWidth, requiredHeight);
    }

    private void UpdatePlacement(PlacementInfo placements)
    {
        ModuleOpPoses = placements.NodePositions;

        Point moduleSize = Point.Max(MinContentSize, placements.SpaceNeeded);

        //With new module size, the io positions need to be updated
        InputOffsets = OnMakeInputs(moduleSize.X, moduleSize.Y);
        OutputOffsets = OnMakeOutputs(moduleSize.X, moduleSize.Y);
        CurrModCtrl.UpdateIOFromNode(Operation, InputOffsets, OutputOffsets);

        CurrModCtrl.RouteWires(placements);

        SetCurrentSize(moduleSize);
        StateHasChanged();
    }

    protected override List<DirectedIO> OnMakeInputs(int width, int height)
    {
        return IOPositionCalc.EvenVertical<Input>(height, Operation.InternalInputs, width + ContentPadding, MarginForIO);
    }

    protected override List<DirectedIO> OnMakeOutputs(int width, int height)
    {
        return IOPositionCalc.EvenVertical<Output>(height, Operation.InternalOutputs, -ContentPadding, MarginForIO);
    }
}
