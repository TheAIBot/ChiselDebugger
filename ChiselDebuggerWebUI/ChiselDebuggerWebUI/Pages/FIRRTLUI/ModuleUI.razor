@inherits FIRBase<Module>

<div class="module" style="left:@Position.X.ToPixels();top:@Position.Y.ToPixels();">
    <div class="moduleHeader">
        <h2>@Operation.Name</h2>
    </div>
    <div style="padding:@ContentPadding.ToPixels();">
        <div class="moduleContent" @ref="SizeWatcher" style="width:@GetCurrentSize().X.ToPixels();height:@GetCurrentSize().Y.ToPixels();min-width:@MinContentSize.X.ToPixels();min-height:@MinContentSize.Y.ToPixels()">
            @foreach (var posOp in ModuleOpPoses)
            {
                @if (posOp.Value is Mux)
                {
                    <MuxOp PosOp="@(posOp.Cast<Mux>())" OnComponentUpdate="@UpdateComponentInfo"></MuxOp>
                }
                else if (posOp.Value is BiArgMonoResPrimOp)
                {
                    <BiArgMonoResPrimOpUI PosOp="@(posOp.Cast<BiArgMonoResPrimOp>())" OnComponentUpdate="@UpdateComponentInfo"></BiArgMonoResPrimOpUI>
                }
            }

            @foreach (var input in InputOffsets)
            {
                <IOPortUI Position="@input.Position"></IOPortUI>
            }

            @foreach (var output in OutputOffsets)
            {
                <IOPortUI Position="@output.Position"></IOPortUI>
            }

            <WiresUI Paths="@ModuleConnections"></WiresUI>
        </div>
    </div>
</div>

@code
{
    private const int ContentPadding = 20;
    private Point MinContentSize;
    private List<Positioned<FIRRTLNode>> ModuleOpPoses = new List<Positioned<FIRRTLNode>>();

    private const int MarginForIO = 20;
    private const int MinSpaceBetweenIO = 15;
    private const int MaxSpaceBetweenIO = 40;
    private List<WirePath> ModuleConnections = new List<WirePath>();

    private ConnectionsHandler ConHandler;
    private Placer NodePlacer;
    private SimpleRouter WireRouter;

    protected override void OnFirstParametersSetAsync()
    {
        MinContentSize = GetMinSizeForIO();

        NodePlacer = new Placer(Operation);
        NodePlacer.OnPlacedNodes += UpdatePlacement;
        ModuleOpPoses = Operation.GetAllNodes().Select(x => new Positioned<FIRRTLNode>(new Point(0, 0), x)).ToList();

        ConHandler = new ConnectionsHandler(Operation);
        WireRouter = new SimpleRouter(ConHandler);
    }

    protected override bool OnResize(int width, int height)
    {
        base.OnResize(width, height);

        ConHandler.UpdateIOFromNode(Operation, InputOffsets, OutputOffsets);

        return true;
    }

    private Point GetMinSizeForIO()
    {
        int requiredWidth = 0;

        int maxIO = Math.Max(Operation.ExternalInputs.Count, Operation.ExternalOutputs.Count);

        int requiredIOMargin = MarginForIO * 2;
        int requiredHeight = requiredIOMargin + (maxIO - 1) * MinSpaceBetweenIO;

        return new Point(requiredWidth, requiredHeight);
    }

    private void UpdatePlacement(PlacementInfo placements)
    {
        ModuleOpPoses = placements.NodePositions;

        Point moduleSize = Point.Max(MinContentSize, placements.SpaceNeeded);

        //With new module size, the io positions need to be updated
        InputOffsets = OnMakeInputs(moduleSize.X, moduleSize.Y);
        OutputOffsets = OnMakeOutputs(moduleSize.X, moduleSize.Y);
        ConHandler.UpdateIOFromNode(Operation, InputOffsets, OutputOffsets);

        ModuleConnections = WireRouter.PathLines(placements);

        SetCurrentSize(moduleSize);
        StateHasChanged();
    }

    protected override List<DirectedIO> OnMakeInputs(int width, int height)
    {
        return PositionIO<Input>(width, height, Operation.InternalInputs, width + ContentPadding);
    }

    protected override List<DirectedIO> OnMakeOutputs(int width, int height)
    {
        return PositionIO<Output>(width, height, Operation.InternalOutputs, -ContentPadding);
    }

    private List<DirectedIO> PositionIO<T>(int width, int height, List<T> io, int x) where T : FIRIO
    {
        int usableSpace = height - MarginForIO * 2;

        int yStart = MarginForIO;
        int spaceBetweenIO;
        if (io.Count <= 1)
        {
            yStart += usableSpace / 2;
            spaceBetweenIO = 0;
        }
        else
        {
            int spacersNeeded = io.Count - 1;
            int possibleSpaceBetweenIO = usableSpace / spacersNeeded;
            spaceBetweenIO = Math.Min(MaxSpaceBetweenIO, possibleSpaceBetweenIO);
            int usedSpace = spaceBetweenIO * spacersNeeded;

            yStart += (usableSpace - usedSpace) / 2;
        }

        List<DirectedIO> posIO = new List<DirectedIO>();
        for (int i = 0; i < io.Count; i++)
        {
            int y = yStart + spaceBetweenIO * i;

            Point pos = new Point(x, y);
            posIO.Add(new DirectedIO(io[i], pos, MoveDirs.Right));
        }

        return posIO;
    }

    private void UpdateComponentInfo(FIRComponentUpdate updateData)
    {
        ConHandler.UpdateIOFromNode(updateData.Node, updateData.InputOffsets, updateData.OutputOffsets);
        NodePlacer.SetNodeSize(updateData.Node, updateData.Size);
    }
}
