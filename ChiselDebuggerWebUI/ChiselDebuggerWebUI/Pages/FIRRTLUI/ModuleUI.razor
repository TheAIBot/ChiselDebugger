@inherits FIRBase<Module>
@implements IDisposable

<div class="module"  @ref="SizeWatcher" style="left:@Position.X.ToPixels();top:@Position.Y.ToPixels();">
    @*<div class="moduleHeader">
        <h2>@Operation.Name</h2>
    </div>*@
    <div class="moduleContent" style="width:@GetCurrentSize().X.ToPixels();height:@GetCurrentSize().Y.ToPixels();min-width:@MinContentSize.X.ToPixels();min-height:@MinContentSize.Y.ToPixels()">
        @foreach (var posOp in ModuleOpPoses)
        {
            @if (posOp.Value is Mux)
            {
                <MuxOp @key=posOp.Value PosOp="@(posOp.Cast<Mux>())" ParentModCtrl="CurrModCtrl"></MuxOp>
            }
            else if (posOp.Value is BiArgMonoResPrimOp)
            {
                <BiArgMonoResPrimOpUI @key=posOp.Value PosOp="@(posOp.Cast<BiArgMonoResPrimOp>())" ParentModCtrl="CurrModCtrl"></BiArgMonoResPrimOpUI>
            }
            else if (posOp.Value is ConstBitRange)
            {
                <ConstBitRangeUI @key=posOp.Value PosOp="@(posOp.Cast<ConstBitRange>())" ParentModCtrl="CurrModCtrl"></ConstBitRangeUI>
            }
            else if (posOp.Value is Register)
            {
                <RegisterUI @key=posOp.Value PosOp="@(posOp.Cast<Register>())" ParentModCtrl="CurrModCtrl"></RegisterUI>
            }
            else if (posOp.Value is Module)
            {
                <ModuleUI @key=posOp.Value PosOp="@(posOp.Cast<Module>())" ParentModCtrl="CurrModCtrl"></ModuleUI>
            }
        }

        @foreach (var input in InputOffsets)
        {
            <IOPortUI Position="@input.Position"></IOPortUI>
        }

        @foreach (var output in OutputOffsets)
        {
            <IOPortUI Position="@output.Position"></IOPortUI>
        }

        <WiresUI ModCtrl="CurrModCtrl"></WiresUI>
    </div>
</div>

@code
{
    private const int ContentPadding = 0;
    private const int MarginForIO = 20;
    private const int MinSpaceBetweenIO = 15;
    private Point MinContentSize;
    private List<Positioned<FIRRTLNode>> ModuleOpPoses = new List<Positioned<FIRRTLNode>>();
    private ModuleController CurrModCtrl;

    protected override void OnFirstParametersSetAsync()
    {
        base.OnFirstParametersSetAsync();

        MinContentSize = GetMinSizeForIO();

        ModuleOpPoses = Operation.GetAllNodes().Select(x => new Positioned<FIRRTLNode>(Point.Zero, x)).ToList();
        CurrModCtrl = new ModuleController(Operation, this, ParentModCtrl);
        CurrModCtrl.OnPlacedNodes += x => InvokeAsync(() => UpdatePlacement(x));

        DebugCtrl.AddModCtrl(CurrModCtrl, Operation.GetAllNodes());
    }

    protected override bool OnResize(int width, int height)
    {
        //Update this module with its internal io positions
        InputOffsets = OnMakeInputs(width, height);
        OutputOffsets = OnMakeOutputs(width, height);
        CurrModCtrl.UpdateIOFromNode(Operation, InputOffsets, OutputOffsets);

        return true;
    }

    private void UpdateParentAboutExteriorIO(int width, int height)
    {
        var externalInputs = MakeExternalInputs(width, height);
        var externalOutputs = MakeExternalOutputs(width, height);
        ParentModCtrl?.UpdateComponentInfo(new FIRComponentUpdate(Operation, new Point(width, height), externalInputs, externalOutputs));
    }

    private Point GetMinSizeForIO()
    {
        int requiredWidth = 0;

        int maxIO = Math.Max(Operation.GetInputs().Length, Operation.GetOutputs().Length);

        int requiredIOMargin = MarginForIO * 2;
        int requiredHeight = requiredIOMargin + (maxIO - 1) * MinSpaceBetweenIO;

        return new Point(requiredWidth, requiredHeight);
    }

    private void UpdatePlacement(PlacementInfo placements)
    {
        ModuleOpPoses = placements.NodePositions;

        Point moduleSize = Point.Max(MinContentSize, placements.SpaceNeeded);

        //With new module size, the io positions need to be updated
        OnResize(moduleSize.X, moduleSize.Y);
        UpdateParentAboutExteriorIO(moduleSize.X, moduleSize.Y);

        CurrModCtrl.RouteWires(placements);

        CurrModCtrl.PrepareToRerenderModule();
        SetCurrentSize(moduleSize);
        StateHasChanged();
    }

    protected override List<DirectedIO> OnMakeInputs(int width, int height)
    {
        return IOPositionCalc.EvenVertical<Input>(height, Operation.GetInternalInputs(), width + ContentPadding, MarginForIO);
    }

    protected override List<DirectedIO> OnMakeOutputs(int width, int height)
    {
        return IOPositionCalc.EvenVertical<Output>(height, Operation.GetInternalOutputs(), -ContentPadding, MarginForIO);
    }

    private List<DirectedIO> MakeExternalInputs(int width, int height)
    {
        return IOPositionCalc.EvenVertical<Input>(height, Operation.GetInputs(), -ContentPadding, MarginForIO);
    }

    private List<DirectedIO> MakeExternalOutputs(int width, int height)
    {
        return IOPositionCalc.EvenVertical<Output>(height, Operation.GetOutputs(), width + ContentPadding, MarginForIO);
    }

    public void Dispose()
    {
        CurrModCtrl.Dispose();
    }
}
