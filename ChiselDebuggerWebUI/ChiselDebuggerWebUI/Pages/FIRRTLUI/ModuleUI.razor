@inherits FIRBase<Module>
@implements IDisposable

<div id="@SizeWatcherID" class="module" style="left:@Position.X.ToPixels();top:@Position.Y.ToPixels();">
    @*<div class="moduleHeader">
            <h2>@Operation.Name</h2>
        </div>*@
    <div class="moduleContent" style="
    width:@GetCurrentSize().X.ToPixels();
    height:@GetCurrentSize().Y.ToPixels();
    min-width:@MinContentSize.X.ToPixels();
    min-height:@MinContentSize.Y.ToPixels();
    transform: scale(@ContentScale.ToHtmlNumber());">
        @foreach (var posOp in ModuleOpPoses)
        {
            @if (posOp.Value is Mux)
            {
                <MuxOp @key=posOp.Value PosOp="@(posOp.Cast<Mux>())" ParentModCtrl="CurrModCtrl"></MuxOp>
            }
            else if (posOp.Value is MonoArgMonoResPrimOp)
            {
                <MonoArgPrimOpUI @key=posOp.Value PosOp="@(posOp.Cast<MonoArgMonoResPrimOp>())" ParentModCtrl="CurrModCtrl"></MonoArgPrimOpUI>
            }
            else if (posOp.Value is BiArgMonoResPrimOp)
            {
                <BiArgMonoResPrimOpUI @key=posOp.Value PosOp="@(posOp.Cast<BiArgMonoResPrimOp>())" ParentModCtrl="CurrModCtrl"></BiArgMonoResPrimOpUI>
            }
            else if (posOp.Value is ConstBitRange)
            {
                <ConstBitRangeUI @key=posOp.Value PosOp="@(posOp.Cast<ConstBitRange>())" ParentModCtrl="CurrModCtrl"></ConstBitRangeUI>
            }
            else if (posOp.Value is Register)
            {
                <RegisterUI @key=posOp.Value PosOp="@(posOp.Cast<Register>())" ParentModCtrl="CurrModCtrl"></RegisterUI>
            }
            else if (posOp.Value is Module)
            {
                <ModuleUI @key=posOp.Value PosOp="@(posOp.Cast<Module>())" ParentModCtrl="CurrModCtrl"></ModuleUI>
            }
            else if (posOp.Value is Memory)
            {
                <MemoryUI @key=posOp.Value PosOp="@(posOp.Cast<Memory>())" ParentModCtrl="CurrModCtrl"></MemoryUI>
            }
        }

        <WiresUI ModCtrl="CurrModCtrl"></WiresUI>


    </div>
    <ScopedIOUI NodeIO="@ExternalIO"></ScopedIOUI>
</div>

@code
{
    private const int ContentPadding = 0;
    private const int MarginForIO = 20;
    private const int MinSpaceBetweenIO = 15;
    private const float MaxContentScaling = 6.0f;
    private Point MinContentSize;
    private List<Positioned<FIRRTLNode>> ModuleOpPoses = new List<Positioned<FIRRTLNode>>();
    private ModuleController CurrModCtrl;
    private ScopedNodeIO ExternalIO = null;
    private float ContentScale = 1.0f;

    protected override void OnFirstParametersSetAsync()
    {
        base.OnFirstParametersSetAsync();

        MinContentSize = GetMinSizeForIO();

        ModuleOpPoses = Operation.GetAllNodes().Select(x => new Positioned<FIRRTLNode>(Point.Zero, x)).ToList();
        CurrModCtrl = new ModuleController(DebugCtrl, Operation, this, ParentModCtrl);
        CurrModCtrl.OnPlacedNodes += x => InvokeAsync(() => UpdatePlacement(x));
    }

    protected override void OnResize(int width, int height)
    {
        //Update this module with its internal io positions
        ScopedNodeIO internalIO = IOPositionCalc.VerticalScopedIO(Operation.GetInternalIO(), width, MarginForIO, MarginForIO);

        //X position for internal is flipped i.e. input has output x
        //and the other way around. This switches the x values around.
        internalIO.UpdateIOX(width, 0);

        //Scale io the the height of the entire module
        internalIO.ScaleFillY(height, MaxContentScaling);

        internalIO.VerticalRecenter(height);

        CurrModCtrl.UpdateIOFromNode(Operation, internalIO.GetInputDirIO(), internalIO.GetOutputDirIO());
    }

    private Point UpdateParentAboutExteriorIO(Point moduleSize)
    {
        ExternalIO = IOPositionCalc.VerticalScopedIO(Operation.GetIO(), moduleSize.X, MarginForIO, MarginForIO);

        if (moduleSize.Y > ExternalIO.HeightNeeded)
        {
            //Top level module will actuall scale its io.
            //Nested modules will instead Scale the module content
            //to a size better matching the size of the io.
            if (ParentModCtrl == null)
            {
                ExternalIO.ScaleFillY(moduleSize.Y, MaxContentScaling);
            }
            else
            {
                float scaling = ExternalIO.GetMaxScaling(moduleSize.Y, MaxContentScaling);
                ContentScale = 1 / scaling;
                moduleSize /= scaling;
            }

            ExternalIO.UpdateOutputX(moduleSize.X);
        }

        ExternalIO.VerticalRecenter(moduleSize.Y);

        ParentModCtrl?.UpdateComponentInfo(new FIRComponentUpdate(Operation, moduleSize, ExternalIO.GetInputDirIO(), ExternalIO.GetOutputDirIO()));

        return moduleSize;
    }

    private Point GetMinSizeForIO()
    {
        int requiredWidth = 0;
        int requiredHeight = IOPositionCalc.VerticalScopedIO(Operation.GetInternalIO(), 0, MarginForIO, MarginForIO).HeightNeeded;

        return new Point(requiredWidth, requiredHeight);
    }

    private void UpdatePlacement(PlacementInfo placements)
    {
        ModuleOpPoses = placements.NodePositions;

        Point moduleSize = Point.Max(MinContentSize, placements.SpaceNeeded);

        //With new module size, the io positions need to be updated
        OnResize(moduleSize.X, moduleSize.Y);
        moduleSize = UpdateParentAboutExteriorIO(moduleSize);

        CurrModCtrl.RouteWires(placements);

        CurrModCtrl.PrepareToRerenderModule();
        SetCurrentSize(moduleSize);
        StateHasChanged();
    }

    protected override List<DirectedIO> OnMakeInputs(int width, int height)
    {
        return IOPositionCalc.EvenVertical(height, Operation.GetInternalInputs(), width + ContentPadding, MarginForIO);
    }

    protected override List<DirectedIO> OnMakeOutputs(int width, int height)
    {
        return IOPositionCalc.EvenVertical(height, Operation.GetInternalOutputs(), -ContentPadding, MarginForIO);
    }

    private List<DirectedIO> MakeExternalInputs(int width, int height)
    {
        return IOPositionCalc.EvenVertical(height, Operation.GetInputs(), -ContentPadding, MarginForIO);
    }

    private List<DirectedIO> MakeExternalOutputs(int width, int height)
    {
        return IOPositionCalc.EvenVertical(height, Operation.GetOutputs(), width + ContentPadding, MarginForIO);
    }

    public void Dispose()
    {
        CurrModCtrl.Dispose();
    }
}
