@inherits FIRBase<Module>

<div class="module" style="left:@Position.X.ToPixels();top:@Position.Y.ToPixels();">
    <div class="moduleHeader">
        <h2>@Operation.Name</h2>
    </div>
    <div style="padding:@ContentPadding.ToPixels();">
        <div class="moduleContent" @ref="SizeWatcher" style="width:@GetCurrentSize().X.ToPixels();height:@GetCurrentSize().Y.ToPixels();min-width:@MinContentSize.X;min-height:@MinContentSize.Y">
            @foreach (var posOp in ModuleOpPoses)
            {
                @if (posOp.Value is Mux mux)
                {
                    <MuxOp PosOp="@(new Positioned<Mux>(posOp.Position, mux))" OnComponentResized="@UpdateModuleSize" OnIOChangedPosition="@UpdatePrimOpIOPositions"></MuxOp>
                }
                else if (posOp.Value is BiArgMonoResPrimOp biArg)
                {
                    <BiArgMonoResPrimOpUI PosOp="@(new Positioned<BiArgMonoResPrimOp>(posOp.Position, biArg))" OnComponentResized="@UpdateModuleSize" OnIOChangedPosition="@UpdatePrimOpIOPositions"></BiArgMonoResPrimOpUI>
                }
            }

            @foreach (var input in InputOffsets)
            {
                <IOPortUI Position="@input.Position"></IOPortUI>
            }

            @foreach (var output in OutputOffsets)
            {
                <IOPortUI Position="@output.Position"></IOPortUI>
            }

            <svg style="position: absolute;overflow:visible;top: 0;left: 0;width: @GetCurrentSize().X.ToPixels();height: @GetCurrentSize().Y.ToPixels();">
                @foreach (var wire in ModuleConnections)
                {
                    <line x1="@wire.start.X" y1="@wire.start.Y" x2="@wire.end.X" y2="@wire.end.Y" style="stroke:black;stroke-width:2" />
                }
            </svg>
        </div>
    </div>
</div>

@code
{
    private const int ContentPadding = 20;
    private Point MinContentSize;
    private List<Positioned<FIRRTLNode>> ModuleOpPoses = new List<Positioned<FIRRTLNode>>();

    private const int MarginForIO = 20;
    private const int MinSpaceBetweenIO = 15;
    private const int MaxSpaceBetweenIO = 40;
    private List<(Point start, Point end)> ModuleConnections = new List<(Point start, Point end)>();

    private ConnectionsHandler ConHandler;

    protected override Task OnParametersSetAsync()
    {
        MinContentSize = GetMinSizeForIO();
        ModuleOpPoses = PositionModuleComponents(Operation);

        List<FIRRTLNode> nodes = new List<FIRRTLNode>(Operation.PrimOps);
        nodes.Add(Operation);
        ConHandler = new ConnectionsHandler(Operation.GetAllModuleConnections(), nodes);
        ConHandler.OnHasIOFromAllNodes += UpdateConnections;

        return base.OnParametersSetAsync();
    }

    protected override void OnResize(int width, int height)
    {
        base.OnResize(width, height);

        ConHandler.UpdateIOFromNode(Operation, ToAbsolutePositions(InputOffsets), ToAbsolutePositions(OutputOffsets));
    }

    private List<Positioned<FIRRTLNode>> PositionModuleComponents(Module module)
    {
        int x = 0;
        List<Positioned<FIRRTLNode>> positions = new List<Positioned<FIRRTLNode>>();
        foreach (var op in module.PrimOps)
        {
            Point pos = new Point(x, 0);
            positions.Add(new Positioned<FIRRTLNode>(pos, op));

            x += 200;
        }

        return positions;
    }

    private Point GetMinSizeForIO()
    {
        int requiredWidth = 0;

        int maxIO = Math.Max(Operation.ExternalInputs.Count, Operation.ExternalOutputs.Count);

        int requiredIOMargin = MarginForIO * 2;
        int requiredHeight = requiredIOMargin + (maxIO - 1) * MinSpaceBetweenIO;

        return new Point(requiredWidth, requiredHeight);
    }

    private void UpdateConnections()
    {
        ModuleConnections = ConHandler.GetAllConnectionLines();
        StateHasChanged();
    }

    protected override List<Positioned<Input>> OnMakeInputs(int width, int height)
    {
        return PositionIO<Input>(width, height, Operation.InternalInputs, width + ContentPadding);
    }

    protected override List<Positioned<Output>> OnMakeOutputs(int width, int height)
    {
        return PositionIO<Output>(width, height, Operation.InternalOutputs, -ContentPadding);
    }

    private List<Positioned<T>> PositionIO<T>(int width, int height, List<T> io, int x)
    {
        int usableSpace = height - MarginForIO * 2;

        int yStart = MarginForIO;
        int spaceBetweenIO;
        if (io.Count <= 1)
        {
            yStart += usableSpace / 2;
            spaceBetweenIO = 0;
        }
        else
        {
            int spacersNeeded = io.Count - 1;
            int possibleSpaceBetweenIO = usableSpace / spacersNeeded;
            spaceBetweenIO = Math.Min(MaxSpaceBetweenIO, possibleSpaceBetweenIO);
            int usedSpace = spaceBetweenIO * spacersNeeded;

            yStart += (usableSpace - usedSpace) / 2;
        }

        List<Positioned<T>> posIO = new List<Positioned<T>>();
        for (int i = 0; i < io.Count; i++)
        {
            int y = yStart + spaceBetweenIO * i;

            Point pos = new Point(x, y);
            posIO.Add(new Positioned<T>(pos, io[i]));
        }

        return posIO;
    }

    private void UpdateModuleSize(Rectangle componentShape)
    {
        Point currentSize = GetCurrentSize();
        if (currentSize.X < componentShape.RightX ||
            currentSize.Y < componentShape.BottomY)
        {
            currentSize.X = Math.Max(currentSize.X, componentShape.RightX);
            currentSize.Y = Math.Max(currentSize.Y, componentShape.BottomY);

            SetCurrentSize(currentSize);
        }
    }

    private void UpdatePrimOpIOPositions(IOPositionUpdate io)
    {
        ConHandler.UpdateIOFromNode(io.Node, io.Inputs, io.Outputs);
    }
}
