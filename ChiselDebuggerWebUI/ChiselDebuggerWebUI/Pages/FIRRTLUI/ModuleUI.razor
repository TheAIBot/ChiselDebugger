@inherits FIRBase<Module>
@implements IDisposable

<div id="@SizeWatcherID" class="module" style="left:@Position.X.ToPixels();top:@Position.Y.ToPixels();">
    @*<div class="moduleHeader">
            <h2>@Operation.Name</h2>
        </div>*@
    <div class="moduleContent" style="
    width:@GetCurrentSize().X.ToPixels();
    height:@GetCurrentSize().Y.ToPixels();
    min-width:@MinContentSize.X.ToPixels();
    min-height:@MinContentSize.Y.ToPixels();
    transform: scale(@ContentScale.ToHtmlNumber());">
        @foreach (var posOp in ModuleOpPoses)
        {
            @if (posOp.Value is Mux)
            {
                <MuxOp @key=posOp.Value PosOp="@(posOp.Cast<Mux>())" ParentModCtrl="CurrModCtrl"></MuxOp>
            }
            else if (posOp.Value is BiArgMonoResPrimOp)
            {
                <BiArgMonoResPrimOpUI @key=posOp.Value PosOp="@(posOp.Cast<BiArgMonoResPrimOp>())" ParentModCtrl="CurrModCtrl"></BiArgMonoResPrimOpUI>
            }
            else if (posOp.Value is ConstBitRange)
            {
                <ConstBitRangeUI @key=posOp.Value PosOp="@(posOp.Cast<ConstBitRange>())" ParentModCtrl="CurrModCtrl"></ConstBitRangeUI>
            }
            else if (posOp.Value is Register)
            {
                <RegisterUI @key=posOp.Value PosOp="@(posOp.Cast<Register>())" ParentModCtrl="CurrModCtrl"></RegisterUI>
            }
            else if (posOp.Value is Module)
            {
                <ModuleUI @key=posOp.Value PosOp="@(posOp.Cast<Module>())" ParentModCtrl="CurrModCtrl"></ModuleUI>
            }
            else if (posOp.Value is Memory)
            {
                <MemoryUI @key=posOp.Value PosOp="@(posOp.Cast<Memory>())" ParentModCtrl="CurrModCtrl"></MemoryUI>
            }
        }

        <WiresUI ModCtrl="CurrModCtrl"></WiresUI>


    </div>
    <ScopedIOUI NodeIO="@ExternalIO"></ScopedIOUI>
</div>

@code
{
    private const int ContentPadding = 0;
    private const int MarginForIO = 20;
    private const int MinSpaceBetweenIO = 15;
    private const float MaxContentScaling = 3000.0f;
    private Point MinContentSize;
    private List<Positioned<FIRRTLNode>> ModuleOpPoses = new List<Positioned<FIRRTLNode>>();
    private ModuleController CurrModCtrl;
    private ScopedNodeIO ExternalIO = null;
    private float ContentScale = 1.0f;

    protected override void OnFirstParametersSetAsync()
    {
        base.OnFirstParametersSetAsync();

        MinContentSize = GetMinSizeForIO();

        ModuleOpPoses = Operation.GetAllNodes().Select(x => new Positioned<FIRRTLNode>(Point.Zero, x)).ToList();
        CurrModCtrl = new ModuleController(Operation, this, ParentModCtrl);
        CurrModCtrl.OnPlacedNodes += x => InvokeAsync(() => UpdatePlacement(x));

        DebugCtrl.AddModCtrl(CurrModCtrl, Operation.GetAllNodes());
    }

    protected override void OnResize(int width, int height)
    {
        //Update this module with its internal io positions
        ScopedNodeIO internalIO = IOPositionCalc.VerticalScopedIO(Operation.GetInternalIO(), width, MarginForIO, MarginForIO);
        internalIO.UpdateIOX(width, 0);

        float scaling = internalIO.GetMaxScaling(height, MaxContentScaling);// ExternalIO.ScaleFillY(height, MaxContentScaling);
        scaling = Math.Min(3.0f, scaling);
        internalIO.ScaleFillY(height, scaling);

        CurrModCtrl.UpdateIOFromNode(Operation, internalIO.GetInputDirIO(), internalIO.GetOutputDirIO());
    }

    private Point UpdateParentAboutExteriorIO(int width, int height)
    {
        ExternalIO = IOPositionCalc.VerticalScopedIO(Operation.GetIO(), width, MarginForIO, MarginForIO);

        Point moduleSize = new Point(width, height);
        if (ParentModCtrl == null)
        {
            return moduleSize;
        }

        if (height > ExternalIO.HeightNeeded)
        {
            float scaling = ExternalIO.GetMaxScaling(height, MaxContentScaling);// ExternalIO.ScaleFillY(height, MaxContentScaling);
            scaling = Math.Min(3.0f, scaling);
            ContentScale = 1 / scaling;

            moduleSize /= scaling;
            ExternalIO.UpdateOutputX(moduleSize.X);
        }

        ParentModCtrl?.UpdateComponentInfo(new FIRComponentUpdate(Operation, moduleSize, ExternalIO.GetInputDirIO(), ExternalIO.GetOutputDirIO()));

        return moduleSize;
    }

    private Point GetMinSizeForIO()
    {
        int requiredWidth = 0;
        int requiredHeight = IOPositionCalc.VerticalScopedIO(Operation.GetInternalIO(), 0, MarginForIO, MarginForIO).HeightNeeded;

        return new Point(requiredWidth, requiredHeight);
    }

    private void UpdatePlacement(PlacementInfo placements)
    {
        ModuleOpPoses = placements.NodePositions;

        Point moduleSize = Point.Max(MinContentSize, placements.SpaceNeeded);

        //With new module size, the io positions need to be updated
        OnResize(moduleSize.X, moduleSize.Y);
        moduleSize = UpdateParentAboutExteriorIO(moduleSize.X, moduleSize.Y);



        CurrModCtrl.RouteWires(placements);

        CurrModCtrl.PrepareToRerenderModule();
        SetCurrentSize(moduleSize);
        StateHasChanged();
    }

    protected override List<DirectedIO> OnMakeInputs(int width, int height)
    {
        return IOPositionCalc.EvenVertical(height, Operation.GetInternalInputs(), width + ContentPadding, MarginForIO);
    }

    protected override List<DirectedIO> OnMakeOutputs(int width, int height)
    {
        return IOPositionCalc.EvenVertical(height, Operation.GetInternalOutputs(), -ContentPadding, MarginForIO);
    }

    private List<DirectedIO> MakeExternalInputs(int width, int height)
    {
        return IOPositionCalc.EvenVertical(height, Operation.GetInputs(), -ContentPadding, MarginForIO);
    }

    private List<DirectedIO> MakeExternalOutputs(int width, int height)
    {
        return IOPositionCalc.EvenVertical(height, Operation.GetOutputs(), width + ContentPadding, MarginForIO);
    }

    public void Dispose()
    {
        CurrModCtrl.Dispose();
    }
}
