@inherits FIRBase<Module>

<div class="module" style="left:@Position.X.ToPixels();top:@Position.Y.ToPixels();">
    <div class="moduleHeader">
        <h2>@Operation.Name</h2>
    </div>
    <div style="padding:@ContentPadding.ToPixels();">
        <div class="moduleContent" @ref="SizeWatcher" style="width:@GetCurrentSize().X.ToPixels();height:@GetCurrentSize().Y.ToPixels();min-width:@MinContentSize.X;min-height:@MinContentSize.Y">
            @foreach (var posOp in ModuleOpPoses)
            {
                @if (posOp.Value is Mux)
                {
                    <MuxOp PosOp="@(posOp.Cast<Mux>())" OnComponentResized="@UpdateModuleSize" OnIOChangedPosition="@UpdatePrimOpIOPositions"></MuxOp>
                }
                else if (posOp.Value is BiArgMonoResPrimOp)
                {
                    <BiArgMonoResPrimOpUI PosOp="@(posOp.Cast<BiArgMonoResPrimOp>())" OnComponentResized="@UpdateModuleSize" OnIOChangedPosition="@UpdatePrimOpIOPositions"></BiArgMonoResPrimOpUI>
                }
            }

            @foreach (var input in InputOffsets)
            {
                <IOPortUI Position="@input.Position"></IOPortUI>
            }

            @foreach (var output in OutputOffsets)
            {
                <IOPortUI Position="@output.Position"></IOPortUI>
            }

            <svg class="moduleWires" style="width: @GetCurrentSize().X.ToPixels();height: @GetCurrentSize().Y.ToPixels();">
                @foreach (var wire in ModuleConnections)
                {
                    <line class="wire" x1="@wire.Start.X" y1="@wire.Start.Y" x2="@wire.End.X" y2="@wire.End.Y" />
                }
            </svg>
        </div>
    </div>
</div>

@code
{
    private const int ContentPadding = 20;
    private Point MinContentSize;
    private List<Positioned<FIRRTLNode>> ModuleOpPoses = new List<Positioned<FIRRTLNode>>();

    private const int MarginForIO = 20;
    private const int MinSpaceBetweenIO = 15;
    private const int MaxSpaceBetweenIO = 40;
    private List<Line> ModuleConnections = new List<Line>();

    private ConnectionsHandler ConHandler;
    private Placer NodePlacer;

    protected override Task OnParametersSetAsync()
    {
        MinContentSize = GetMinSizeForIO();

        NodePlacer = new Placer(Operation);
        NodePlacer.OnPlacedNodes += UpdatePlacement;
        ModuleOpPoses = Operation.GetAllNodes().Select(x => new Positioned<FIRRTLNode>(new Point(0, 0), x)).ToList();

        List<FIRRTLNode> nodes = new List<FIRRTLNode>(Operation.PrimOps);
        nodes.Add(Operation);
        ConHandler = new ConnectionsHandler(Operation.GetAllModuleConnections(), nodes);
        ConHandler.OnHasIOFromAllNodes += UpdateConnections;

        return base.OnParametersSetAsync();
    }

    protected override void OnResize(int width, int height)
    {
        base.OnResize(width, height);

        ConHandler.UpdateIOFromNode(Operation, ToAbsolutePositions(InputOffsets), ToAbsolutePositions(OutputOffsets));
    }

    private Point GetMinSizeForIO()
    {
        int requiredWidth = 0;

        int maxIO = Math.Max(Operation.ExternalInputs.Count, Operation.ExternalOutputs.Count);

        int requiredIOMargin = MarginForIO * 2;
        int requiredHeight = requiredIOMargin + (maxIO - 1) * MinSpaceBetweenIO;

        return new Point(requiredWidth, requiredHeight);
    }

    private void UpdatePlacement(PlacementInfo placements)
    {
        ModuleOpPoses = placements.NodePositions;

        SetCurrentSize(placements.SpaceNeeded);

        StateHasChanged();
    }

    private void UpdateConnections()
    {
        ModuleConnections = ConHandler.GetAllConnectionLines();
        StateHasChanged();
    }

    protected override List<Positioned<Input>> OnMakeInputs(int width, int height)
    {
        return PositionIO<Input>(width, height, Operation.InternalInputs, width + ContentPadding);
    }

    protected override List<Positioned<Output>> OnMakeOutputs(int width, int height)
    {
        return PositionIO<Output>(width, height, Operation.InternalOutputs, -ContentPadding);
    }

    private List<Positioned<T>> PositionIO<T>(int width, int height, List<T> io, int x)
    {
        int usableSpace = height - MarginForIO * 2;

        int yStart = MarginForIO;
        int spaceBetweenIO;
        if (io.Count <= 1)
        {
            yStart += usableSpace / 2;
            spaceBetweenIO = 0;
        }
        else
        {
            int spacersNeeded = io.Count - 1;
            int possibleSpaceBetweenIO = usableSpace / spacersNeeded;
            spaceBetweenIO = Math.Min(MaxSpaceBetweenIO, possibleSpaceBetweenIO);
            int usedSpace = spaceBetweenIO * spacersNeeded;

            yStart += (usableSpace - usedSpace) / 2;
        }

        List<Positioned<T>> posIO = new List<Positioned<T>>();
        for (int i = 0; i < io.Count; i++)
        {
            int y = yStart + spaceBetweenIO * i;

            Point pos = new Point(x, y);
            posIO.Add(new Positioned<T>(pos, io[i]));
        }

        return posIO;
    }

    private void UpdateModuleSize(SizeUpdate size)
    {
        NodePlacer.SetNodeSize(size.Node, size.Size);
    }

    private void UpdatePrimOpIOPositions(IOPositionUpdate io)
    {
        ConHandler.UpdateIOFromNode(io.Node, io.Inputs, io.Outputs);
    }
}
