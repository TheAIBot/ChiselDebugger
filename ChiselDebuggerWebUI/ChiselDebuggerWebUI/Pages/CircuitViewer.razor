@page "/circuitviewer"
@page "/"
@using FIRRTL
@using VCDReader
@using ChiselDebug.Timeline;

@inject IJSRuntime JS
@inherits ManualRenderBase

<CascadingValue Value="@DebugCtrl" Name="DebugCtrl" IsFixed="true">
    @if (DebugCtrl.Timeline != null)
    {
        <TimelineUI />
    }

    <div style="height:20px;" />
    <div id="CircuitContainer" class="Circuit" style="transform: translate(@CircuitOffset.X.ToPixels(), @CircuitOffset.Y.ToPixels()) scale(@CircuitScale.ToHtmlNumber());" @onwheel="HandleScroll">
        @foreach (var modulePos in ModulePositions)
        {
            <ModuleUI PosOp="@modulePos" />
        }
    </div>
</CascadingValue>

@code
{

    private DebugController DebugCtrl;
    private List<Positioned<ChiselDebug.GraphFIR.Module>> ModulePositions = new List<Positioned<ChiselDebug.GraphFIR.Module>>();
    private float CircuitScale = 1.0f;
    private Point CircuitOffset = new Point(0, 0);

    protected override void OnInitialized()
    {
        //var circuit = FIRRTL.Parse.FromFile("Examples/MovingAveragePow2.lo.fir");
        //var vcd = VCDReader.Parse.FromFile("Examples/MovingAveragePow2.vcd");
        var circuit = FIRRTL.Parse.FromFile("Examples/RegFileVec.lo.fir");
        var vcd = VCDReader.Parse.FromFile("Examples/RegFileVec.vcd");
        //var circuit = FIRRTL.Parse.FromFile("Examples/FSM.lo.fir");
        //VCD vcd = null;
        CircuitGraph graph = CircuitToGraph.GetAsGraph(circuit);
        graph.InferTypes();

        DebugCtrl = new DebugController(graph, vcd);
        DebugCtrl.OnReRender += () => InvokeAsync(StateHasChanged);

        ModulePositions.Add(new Positioned<ChiselDebug.GraphFIR.Module>(new Point(0, 0), graph.Modules[0]));
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSEvents.AddDragListener(JS, "CircuitContainer", x => InvokeAsync(() => HandleDrag(x)));
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private void HandleScroll(WheelEventArgs args)
    {
        float scaleDelta = args.DeltaY > 0 ? 0.1f : -0.1f;
        CircuitScale -= scaleDelta;
        CircuitScale = Math.Clamp(CircuitScale, 0.1f, 10.0f);

        CircuitOffset.X += (int)(args.OffsetX * scaleDelta);
        CircuitOffset.Y += (int)(args.OffsetY * scaleDelta);

        StateHasChanged();
    }

    private void HandleDrag(Point dragged)
    {
        CircuitOffset += dragged;
        StateHasChanged();
    }
}
