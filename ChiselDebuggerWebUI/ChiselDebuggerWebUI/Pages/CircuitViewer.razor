@page "/circuitviewer/{filename?}"
@page "/"
@using FIRRTL
@using VCDReader
@using ChiselDebug.Timeline;
@using System.IO;

@inject IJSRuntime JS
@inherits ManualRenderBase
@implements IDisposable

@if (DebugCtrl != null)
{
    <CascadingValue Value="@DebugCtrl" Name="DebugCtrl" IsFixed="true">
        <div id="@CircuitContainerID">
            @if (DebugCtrl.Timeline != null)
            {
                <TimelineUI />
            }

            <div style="height:20px;" />
            <div id="@DragEventID" @ref="CircuitContainer" style="
        width: calc(100vw - @CircuitTopLeftParent.X.ToPixels());
        height: calc(100vh - @CircuitTopLeftParent.Y.ToPixels());
        overflow: hidden;
        user-select: none;">
                <div class="Circuit" style="transform: translate( @CircuitOffset.X.ToPixels(), @CircuitOffset.Y.ToPixels() ) scale( @CircuitScale.ToHtmlNumber() );" @onwheel="HandleScroll">
                    <ModuleUI PosOp="@ModulePosition" ParentLayoutCtrl="RootModLayout" />
                </div>
            </div>
        </div>
    </CascadingValue>
}

@code
{
    [Parameter]
    public string Filename { get; set; }

    private DebugController DebugCtrl = null;
    private Positioned<ChiselDebug.GraphFIR.Module> ModulePosition;
    private CircuitLayout RootModLayout = new CircuitLayout();
    private float CircuitScale = 1.0f;
    private Point CircuitOffset = Point.Zero;
    private bool JustLoadedCircuit = false;

    private ElementReference CircuitContainer;
    private readonly string DragEventID = UniqueID.UniqueHTMLID();

    private Point CircuitTopLeftParent = Point.Zero;
    private readonly string CircuitContainerID = UniqueID.UniqueHTMLID();

    protected override async Task OnInitializedAsync()
    {
        string loFirPath = System.IO.Path.Combine("Examples", Filename.Replace(".fir", ".lo.fir"));
        string hiFirPath = System.IO.Path.Combine("Examples", Filename.Replace('-', '.'));
        string vcdPath = System.IO.Path.Combine("Examples", Path.GetFileNameWithoutExtension(Filename) + ".vcd");

        await Task.Factory.StartNew(() => LoadFirData(loFirPath, hiFirPath, vcdPath, true));
        await base.OnInitializedAsync();
    }

    private void LoadFirData(string loFirPath, string hiFirPath, string vcdPath, bool isVerilogVCD)
    {
        CircuitGraph loGraph = null;
        if (File.Exists(loFirPath))
        {
            Circuit locircuit = FIRRTL.Parse.FromFile(loFirPath);
            loGraph = CircuitToGraph.GetAsGraph(locircuit);
        }

        Circuit circuit = FIRRTL.Parse.FromFile(hiFirPath);
        CircuitGraph graph = CircuitToGraph.GetAsGraph(circuit, loGraph);

        ModulePosition = new Positioned<ChiselDebug.GraphFIR.Module>(Point.Zero, graph.MainModule);
        DebugCtrl = new DebugController(graph);

        JustLoadedCircuit = true;
        InvokestateHasChanged();

        if (File.Exists(vcdPath))
        {
            using VCD vcd = VCDReader.Parse.FromFile(vcdPath);
            DebugCtrl.AddVCD(vcd, isVerilogVCD);

            InvokestateHasChanged();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (JustLoadedCircuit)
        {
            JustLoadedCircuit = false;
            await JSEvents.AddDragListener(JS, DragEventID, x => InvokeAsync(() => HandleDrag(x)));
            JSEvents.AddResizeListener(JS, CircuitContainerID, PageResized);
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private async void PageResized(ElemWH size)
    {
        CircuitTopLeftParent = (await JS.InvokeAsync<ElemWH>("JSUtils.getElementPosition", CircuitContainer)).ToPoint();
    }

    /// <summary>
    /// Handles zooming in on the circuit while preserving the mouse relative
    /// position on the circuit while doing so. It does this by translating
    /// the circuit as needed.
    /// </summary>
    /// <param name="args"></param>
    private void HandleScroll(WheelEventArgs args)
    {
        //No matter how much is scrolled, handle it as if it has only
        //scrolled once. This is done to prevent Accidentally zooming
        //too fast.
        float delta = args.DeltaY > 0 ? 0.9f : 1.1f;

        //Limit zooming to some reasonable range
        float newScale = Math.Clamp(CircuitScale * delta, 0.0000005f, 200000.0f);
        float scaleDelta = CircuitScale - newScale;

        //ClientX and ClientY are relative to the viewport.
        //relMouse should be relative to the circuit itself which is why it's
        //translated by the circuit starting position and its current offset.
        float relMouseX = (float)args.ClientX - CircuitOffset.X - CircuitTopLeftParent.X;
        float relMouseY = (float)args.ClientY - CircuitOffset.Y - CircuitTopLeftParent.Y;


        float circuitSizeX = DebugCtrl.CircuitSize.X * CircuitScale;
        float circuitSizeY = DebugCtrl.CircuitSize.Y * CircuitScale;

        //These represent the position of the mouse as a percentage distance
        //to the bottom right of the circuit. Is used to know how much
        //the circuit should be translated in order to preserve the mouse
        //relative position on the circuit.
        float moveX = relMouseX / circuitSizeX;
        float moveY = relMouseY / circuitSizeY;

        //If the mouse is outside the circuit then handle as if the mouse
        //is on the border of the circuit. Prevents translating the circuit
        //completely off the screen if scrolling too far from the circuit.
        moveX = Math.Clamp(moveX, 0, 1);
        moveY = Math.Clamp(moveY, 0, 1);

        //When zooming in, the circuits top left position is unchanged.
        //In order to preserve the mouse relative position, the circuit
        //is translated by however much the circuit size would increase
        //by multiplied by the mouse position relative to the circuits
        //top left position.
        float xOffset = moveX * DebugCtrl.CircuitSize.X * scaleDelta;
        float yOffset = moveY * DebugCtrl.CircuitSize.Y * scaleDelta;

        CircuitScale = newScale;
        CircuitOffset.X += (int)xOffset;
        CircuitOffset.Y += (int)yOffset;

        RootModLayout.UpdateLayoutDisplay(CircuitScale);
        StateHasChanged();
    }

    private void HandleDrag(Point dragged)
    {
        CircuitOffset += dragged;
        StateHasChanged();
    }

    public void Dispose()
    {
        DebugCtrl?.Dispose();
    }
}
