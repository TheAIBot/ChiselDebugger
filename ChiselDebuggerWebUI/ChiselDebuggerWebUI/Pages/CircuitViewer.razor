@page "/circuitviewer/{filename?}"
@page "/"
@using FIRRTL
@using VCDReader
@using ChiselDebug.Timeline;

@inject IJSRuntime JS
@inherits ManualRenderBase
@implements IDisposable

<CascadingValue Value="@DebugCtrl" Name="DebugCtrl" IsFixed="true">
    <div id="@CircuitContainerID">
        @if (DebugCtrl.Timeline != null)
        {
            <TimelineUI />
        }

        <div style="height:20px;" />
        <div id="@DragEventID" @ref="CircuitContainer" style="
        width: calc(100vw - @CircuitTopLeftParent.X.ToPixels());
        height: calc(100vh - @CircuitTopLeftParent.Y.ToPixels());
        overflow: hidden;
        user-select: none;">
            <div class="Circuit" style="transform: translate( @CircuitOffset.X.ToPixels(), @CircuitOffset.Y.ToPixels() ) scale( @CircuitScale.ToHtmlNumber() );" @onwheel="HandleScroll">
                <ModuleUI PosOp="@ModulePosition" />
            </div>
        </div>
    </div>
</CascadingValue>

@code
{
    [Parameter]
    public string Filename { get; set; }

    private DebugController DebugCtrl;
    private Positioned<ChiselDebug.GraphFIR.Module> ModulePosition;
    private float CircuitScale = 1.0f;
    private Point CircuitOffset = Point.Zero;

    private ElementReference CircuitContainer;
    private readonly string DragEventID = UniqueID.UniqueHTMLID();

    private Point CircuitTopLeftParent = Point.Zero;
    private readonly string CircuitContainerID = UniqueID.UniqueHTMLID();

    protected override Task OnInitializedAsync()
    {
        string firrtl = @"
circuit ModL :
    module ModL :
        input clock : Clock
        input reset : UInt<1>
        output io : {flip en1 : UInt<1>, flip en2 : UInt<1>, flip din1 : UInt<8>, dout1 : UInt<8>, flip en3 : UInt<1>, flip en4 : UInt<1>, flip din2 : UInt<8>, dout2 : UInt<8>}

        wire wir : UInt<8> @[SimpleModules.scala 170:19]
        wir <= UInt<1>(""h00"") @[SimpleModules.scala 171:9]
        when io.en1: @[SimpleModules.scala 173:18]
            wir <= io.din1 @[SimpleModules.scala 174:13]
            skip @[SimpleModules.scala 173:18]
        when io.en2: @[SimpleModules.scala 177:18]
            io.dout1 <= wir @[SimpleModules.scala 178:18]
            skip @[SimpleModules.scala 177:18]
        else : @[SimpleModules.scala 179:17]
            io.dout1 <= UInt<2>(""h03"") @[SimpleModules.scala 180:18]
            skip @[SimpleModules.scala 179:17]
        when io.en3 : @[SimpleModules.scala 183:18]
            wir <= io.din2 @[SimpleModules.scala 184:13]
            skip @[SimpleModules.scala 183:18]
        when io.en4 : @[SimpleModules.scala 187:18]
            io.dout2 <= wir @[SimpleModules.scala 188:18]
            skip @[SimpleModules.scala 187:18]
        else : @[SimpleModules.scala 189:17]
            io.dout2 <= UInt<3>(""h07"") @[SimpleModules.scala 190:18]
            skip @[SimpleModules.scala 189:17]";

        Circuit circuit;
        if (Filename == null)
        {
            circuit = FIRRTL.Parse.FromString(firrtl);
        }
        else
        {
            circuit = FIRRTL.Parse.FromFile(System.IO.Path.Combine("Examples", Filename.Replace('-', '.')));
        }
        using VCD vcd = null;// VCDReader.Parse.FromFile("Examples/FSMDatapath.vcd");
        CircuitGraph graph = CircuitToGraph.GetAsGraph(circuit);
        graph.InferTypes();

        DebugCtrl = new DebugController(graph, vcd);

        ModulePosition = new Positioned<ChiselDebug.GraphFIR.Module>(Point.Zero, graph.MainModule);

        return base.OnInitializedAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JSEvents.AddDragListener(JS, DragEventID, x => InvokeAsync(() => HandleDrag(x)));
            JSEvents.AddResizeListener(JS, CircuitContainerID, PageResized);
        }

        await base.OnAfterRenderAsync(firstRender);
    }

    private async void PageResized(ElemWH size)
    {
        CircuitTopLeftParent = (await JS.InvokeAsync<ElemWH>("JSUtils.getElementPosition", CircuitContainer)).ToPoint();
    }

    /// <summary>
    /// Handles zooming in on the circuit while preserving the mouse relative
    /// position on the circuit while doing so. It does this by translating
    /// the circuit as needed.
    /// </summary>
    /// <param name="args"></param>
    private void HandleScroll(WheelEventArgs args)
    {
        //No matter how much is scrolled, handle it as if it has only
        //scrolled once. This is done to prevent Accidentally zooming
        //too fast.
        float delta = args.DeltaY > 0 ? 0.9f : 1.1f;

        //Limit zooming to some reasonable range
        float newScale = Math.Clamp(CircuitScale * delta, 0.00005f, 200.0f);
        float scaleDelta = CircuitScale - newScale;

        //ClientX and ClientY are relative to the viewport.
        //relMouse should be relative to the circuit itself which is why it's
        //translated by the circuit starting position and its current offset.
        float relMouseX = (float)args.ClientX - CircuitOffset.X - CircuitTopLeftParent.X;
        float relMouseY = (float)args.ClientY - CircuitOffset.Y - CircuitTopLeftParent.Y;


        float circuitSizeX = DebugCtrl.CircuitSize.X * CircuitScale;
        float circuitSizeY = DebugCtrl.CircuitSize.Y * CircuitScale;

        //These represent the position of the mouse as a percentage distance
        //to the bottom right of the circuit. Is used to know how much
        //the circuit should be translated in order to preserve the mouse
        //relative position on the circuit.
        float moveX = relMouseX / circuitSizeX;
        float moveY = relMouseY / circuitSizeY;

        //If the mouse is outside the circuit then handle as if the mouse
        //is on the border of the circuit. Prevents translating the circuit
        //completely off the screen if scrolling too far from the circuit.
        moveX = Math.Clamp(moveX, 0, 1);
        moveY = Math.Clamp(moveY, 0, 1);

        //When zooming in, the circuits top left position is unchanged.
        //In order to preserve the mouse relative position, the circuit
        //is translated by however much the circuit size would increase
        //by multiplied by the mouse position relative to the circuits
        //top left position.
        float xOffset = moveX * DebugCtrl.CircuitSize.X * scaleDelta;
        float yOffset = moveY * DebugCtrl.CircuitSize.Y * scaleDelta;

        CircuitScale = newScale;
        CircuitOffset.X += (int)xOffset;
        CircuitOffset.Y += (int)yOffset;

        StateHasChanged();
    }

    private void HandleDrag(Point dragged)
    {
        CircuitOffset += dragged;
        StateHasChanged();
    }

    public void Dispose()
    {
        DebugCtrl.Dispose();
    }
}
